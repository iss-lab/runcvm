#!/bin/bash

# References:
# - https://github.com/joshkunz/qemu-docker
# - https://mergeboard.com/blog/2-qemu-microvm-docker/
# - https://vmsplice.net/~stefan/virtio-fs_%20A%20Shared%20File%20System%20for%20Virtual%20Machines.pdf
# - https://virtio-fs.gitlab.io/howto-qemu.html
# - https://www.tauceti.blog/posts/qemu-kvm-share-host-directory-with-vm-with-virtio/

jq_set() {
  local file="$1"
  shift
  
  local tmp="/tmp/config.json.$$"

  if jq "$@" $file >$tmp; then
    mv $tmp $file
  else
    echo "Failed to update $(basename $file); aborting!" 2>&1
    exit 1
  fi
}

jq_get() {
  local file="$1"
  shift
  
  jq -r "$@" $file
}

LOG=/tmp/dkvm.log
DKVM=/opt/dkvm
DKVM_ENTRYPOINT=/opt/dkvm/scripts/dkvm-ctr-entrypoint
DKVM_EXEC=/opt/dkvm/scripts/dkvm-ctr-exec
DKVM_INIT=/opt/dkvm/scripts/dkvm-vm-init
DKVM_KERNEL_MODULES=/opt/dkvm/kernels/debian/latest/modules

echo "$0 ${@@Q}" >>$LOG

# FIXME: Write resilient command-line parsing logic

# PARSE RUNC GLOBAL OPTIONS:
# --debug             enable debug logging
# --log value         set the log file to write runc logs to (default is '/dev/stderr')
# --log-format value  set the log format ('text' (default), or 'json') (default: "text")
# --root value        root directory for storage of container state (this should be located in tmpfs) (default: "/run/user/1000/runc")
# --criu value        path to the criu binary used for checkpoint and restore (default: "criu")
# --systemd-cgroup    enable systemd cgroup support, expects cgroupsPath to be of form "slice:prefix:name" for e.g. "system.slice:runc:434234"
# --rootless value    ignore cgroup permission errors ('true', 'false', or 'auto') (default: "auto")

COMMAND_LINE=("$@")

while true
do
  case "$1" in
    --debug|--systemd-cgroup) shift; continue; ;;
    --log|--log-format|--root|--criu|--rootless) shift; shift; continue; ;;
    --log=*|--log-format=*|--root=*|--criu=*|--rootless=*) shift; continue; ;;
    *) break; ;;
  esac
done

COMMAND="$1"
shift

if [ "$COMMAND" = "create" ]; then

  echo "create ${@@Q}" >>$LOG
  
  # USAGE:
  #    runc create [command options] <container-id>
  #   
  # PARSE 'create' COMMAND OPTIONS
  # --bundle value, -b value  path to the root of the bundle directory, defaults to the current directory
  # --console-socket value    path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal
  # --pid-file value          specify the file to write the process id to
  # --no-pivot                do not use pivot root to jail process inside rootfs.  This should be used whenever the rootfs is on top of a ramdisk
  # --no-new-keyring          do not create a new session keyring for the container.  This will cause the container to inherit the calling processes session key
  # --preserve-fds value      Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total) (default: 0)
  while true
  do
    case "$1" in
      --bundle|-b) shift; BUNDLE="$1"; shift; continue; ;;
      --console-socket|--pid-file|--preserve-fds) shift; shift; continue; ;;
      --no-pivot|--no-new-keyring) shift; continue; ;;
      *) break; ;;
    esac
  done

  ID="$1"
  
  CFG="$BUNDLE/config.json"

  ls -l $BUNDLE >>$LOG
  cp -a $BUNDLE /tmp/
  
  ROOT=$(jq -r .root.path $CFG)
  echo "ID $ID" >>$LOG
  echo "ROOT=$ROOT" >>$LOG

  # [UNIMPLEMENTED]
  # Optionally, launch virtiofsd on host and bind-mount socket into container
  # HOST_SOCKET="/tmp/.virtiofs-$ID.sock"
  # touch $HOST_SOCKET
  # /usr/lib/qemu/virtiofsd --socket-path=$HOST_SOCKET -o cache=always -o source=$ROOT >/tmp/virtiofsd.log 2>&1 &  
  
  DKVM_KERNEL=$(jq_get "$CFG" '.process.env[] | select(match("^DKVM_KERNEL=")) | match("^DKVM_KERNEL=(.*)") | .captures[] | .string')
  if [ -n "$DKVM_KERNEL" ]; then
    DKVM_KERNEL_MODULES="/opt/dkvm/kernels/$DKVM_KERNEL/modules"
  fi
  
  jq_set "$CFG" --arg entrypoint "$DKVM_ENTRYPOINT" '.process.args |= [$entrypoint] + .'
  jq_set "$CFG" --arg entrypoint "$DKVM_ENTRYPOINT" --arg dkvm "$DKVM" --arg init "$DKVM_INIT" --arg modules "$DKVM_KERNEL_MODULES" '.mounts += [{"destination":$dkvm,"type":"bind","source":$dkvm,"options":["rbind","rprivate","ro"]},{"destination":"/lib/modules","type":"bind","source":$modules,"options":["rbind","rprivate","ro"]}]'
  jq_set "$CFG" '.linux.resources.devices += [{"allow":true,"type":"c","major":10,"minor":232,"access":"rwm"},{"allow":true,"type":"c","major":10,"minor":200,"access":"rwm"}]'
  jq_set "$CFG" '.linux.devices+=[{"path":"/dev/net/tun","type":"c","major":10,"minor":200,"fileMode":8630,"uid":0,"gid":0},{"path":"/dev/kvm","type":"c","major":10,"minor":232,"fileMode":8630,"uid":0,"gid":0}]'
  jq_set "$CFG" '.process.capabilities.bounding += ["CAP_NET_ADMIN"] | .process.capabilities.effective += ["CAP_NET_ADMIN"] | .process.capabilities.permitted += ["CAP_NET_ADMIN"]'
  jq_set "$CFG" '( .mounts[] | select(.source == "shm") ).options = ["nosuid","noexec","nodev","mode=1777","size=68719476736"]'
  
  # Filter for DKVM_SYS_ADMIN=1
  DKVM_SYS_ADMIN=$(jq_get "$CFG" '.process.env | map(select(test("^DKVM_SYS_ADMIN="))) | length')
  if [ "$DKVM_SYS_ADMIN" = "1" ]; then
    jq_set "$CFG" '.process.capabilities.bounding += ["CAP_SYS_ADMIN"] | .process.capabilities.effective += ["CAP_SYS_ADMIN"] | .process.capabilities.permitted += ["CAP_SYS_ADMIN"]'    
  fi
  
  # cp $D/config.json /tmp/config.json-$ID

elif [ "$COMMAND" = "exec" ]; then

  echo "exec ${@@Q}" >>$LOG

  # USAGE:
  #   runc exec [command options] <container-id> <command> [command options]  || -p process.json <container-id>
  #
  # PARSE 'exec' COMMAND OPTIONS
  # --console-socket value             path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal
  # --cwd value                        current working directory in the container
  # --env value, -e value              set environment variables
  # --tty, -t                          allocate a pseudo-TTY
  # --user value, -u value             UID (format: <uid>[:<gid>])
  # --additional-gids value, -g value  additional gids
  # --process value, -p value          path to the process.json
  # --detach, -d                       detach from the container's process
  # --pid-file value                   specify the file to write the process id to
  # --process-label value              set the asm process label for the process commonly used with selinux
  # --apparmor value                   set the apparmor profile for the process
  # --no-new-privs                     set the no new privileges value for the process
  # --cap value, -c value              add a capability to the bounding set for the process
  # --preserve-fds value               Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total) (default: 0)
  # --cgroup value                     run the process in an (existing) sub-cgroup(s). Format is [<controller>:]<cgroup>.
  # --ignore-paused                    allow exec in a paused container    
  while true
  do
    case "$1" in
      --console-socket|--cwd|--env|-e|--user|-u|--additional-gids|-g|--pid-file|--process-label|--apparmor|--cap|-c|--preserve-fds|--cgroup) shift; shift; continue; ;;
      --tty|-t|--detach|-d|--no-new-privs|--ignore-paused) shift; continue; ;;
      --process|-p) shift; PROCESS="$1"; continue; ;;
      *) break; ;;
    esac
  done
  
  ARG1=$(jq_get "$PROCESS" '.args[0]')
  if [ "$ARG1" = "---" ]; then
    jq_set "$PROCESS" 'del(.args[0])'
  else
    jq_set "$PROCESS" --arg exec "$DKVM_EXEC" '.args |= [$exec] + .'
  fi
  
  cat $PROCESS >>$LOG
fi

echo >>$LOG

exec /usr/bin/runc "${COMMAND_LINE[@]}"
