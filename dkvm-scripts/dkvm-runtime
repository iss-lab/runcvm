#!/opt/dkvm/bin/bash

# REFERENCES

# Qemu:
# - https://github.com/joshkunz/qemu-docker
# - https://mergeboard.com/blog/2-qemu-microvm-docker/
# - https://github.com/BBVA/kvm

# Virtiofs
# - https://vmsplice.net/~stefan/virtio-fs_%20A%20Shared%20File%20System%20for%20Virtual%20Machines.pdf
# - https://virtio-fs.gitlab.io/howto-qemu.html
# - https://www.tauceti.blog/posts/qemu-kvm-share-host-directory-with-vm-with-virtio/

# Container config.json spec
# - https://github.com/opencontainers/runtime-spec/
# - https://github.com/opencontainers/runtime-spec/blob/main/config.md

# Mount namespaces
# - https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt
# - https://www.redhat.com/sysadmin/mount-namespaces

LOG=/tmp/dkvm.log
DKVM=/opt/dkvm
DKVM_VM_MOUNTPOINT="/vm"
DKVM_ENTRYPOINT=$DKVM/scripts/dkvm-ctr-entrypoint
DKVM_EXEC=$DKVM/scripts/dkvm-ctr-exec
DKVM_KERNELS=$DKVM/kernels
DKVM_MEM_SIZE_DEFAULT="1G"
DKVM_DEBUG=1

debug() {
  [ -n "$DKVM_DEBUG" ] && true || false
}

log() {
  debug && echo "$@" >>$LOG
}

error() {

  # Skip past any docker error ending in CR
  (echo; echo) >&2

  # Dump message to stderr
  echo "DKVM: Error: $1" >&2

  #Â Dump error also to the logfile
  log "DKVM: Error: $1"
  exit -1
}

load_env_from_file() {
  local file="$1"
  local var="$2"

  while read LINE
  do
    local name="${LINE%%=*}"
    local value="${LINE#*=}"
    
    if [ "$name" != "$LINE" ] && [ "$value" != "$LINE" ] && [ "$name" = "$var" ]; then
      # We found variable $name: return it, removing any leading/trailing double quotes
      echo "$value" | sed 's/^"//;s/"$//'
      return 0
    fi
  done <"$file"
  
  return 1
}

jq_set() {
  local file="$1"
  shift
  
  local tmp="/tmp/config.json.$$"

  if jq "$@" $file >$tmp; then
    mv $tmp $file
  else
    echo "Failed to update $(basename $file); aborting!" 2>&1
    exit 1
  fi
}

jq_get() {
  local file="$1"
  shift
  
  jq -r "$@" $file
}

jq_get_join() {
  local file="$1"
  shift
  
  jq -j "$@" $file
}

get_config_env() {
  local var="$1"
  local default="$2"
  local value=$(jq_get "$CFG" --arg env "$var" '.process.env[] | select(match("^" + $env + "=")) | match("^" + $env + "=(.*)") | .captures[] | .string')
  
  [ -n "$value" ] && echo -n "$value" || echo -n "$default"
}

set_config_env() {
  local var="$1"
  local value="$2"
  
  jq_set "$CFG" --arg env "$var=$value" '.process.env |= (.+ [$env] | unique)'
}


# PARSE RUNC GLOBAL OPTIONS:
# --debug             enable debug logging
# --log value         set the log file to write runc logs to (default is '/dev/stderr')
# --log-format value  set the log format ('text' (default), or 'json') (default: "text")
# --root value        root directory for storage of container state (this should be located in tmpfs) (default: "/run/user/1000/runc")
# --criu value        path to the criu binary used for checkpoint and restore (default: "criu")
# --systemd-cgroup    enable systemd cgroup support, expects cgroupsPath to be of form "slice:prefix:name" for e.g. "system.slice:runc:434234"
# --rootless value    ignore cgroup permission errors ('true', 'false', or 'auto') (default: "auto")

COMMAND_LINE=("$@")

debug && log "--- LOG BEGINS ---"
echo "Command line: $0 ${COMMAND_LINE[@]@Q}" >>$LOG

while true
do
  case "$1" in
    --debug|--systemd-cgroup) shift; continue; ;;
    --log|--log-format|--root|--criu|--rootless) shift; shift; continue; ;;
    --log=*|--log-format=*|--root=*|--criu=*|--rootless=*) shift; continue; ;;
    *) break; ;;
  esac
done

COMMAND="$1"
shift

if [ "$COMMAND" = "create" ]; then

  debug && log "Command: create"
  
  # USAGE:
  #    runc create [command options] <container-id>
  #   
  # PARSE 'create' COMMAND OPTIONS
  # --bundle value, -b value  path to the root of the bundle directory, defaults to the current directory
  # --console-socket value    path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal
  # --pid-file value          specify the file to write the process id to
  # --no-pivot                do not use pivot root to jail process inside rootfs.  This should be used whenever the rootfs is on top of a ramdisk
  # --no-new-keyring          do not create a new session keyring for the container.  This will cause the container to inherit the calling processes session key
  # --preserve-fds value      Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total) (default: 0)
  while true
  do
    case "$1" in
      --bundle|-b) shift; BUNDLE="$1"; shift; continue; ;;
      --console-socket|--pid-file|--preserve-fds) shift; shift; continue; ;;
      --no-pivot|--no-new-keyring) shift; continue; ;;
      *) break; ;;
    esac
  done

  ID="$1"


  CFG="$BUNDLE/config.json"
  ROOT=$(jq -r .root.path $CFG)

  if debug; then
    log "Command: create bundle=$BUNDLE id=$ID root=$ROOT"
    
    # Save formatted config.json
    jq -r . <$CFG >/tmp/config.json-$$-1
    
  fi

  # [UNIMPLEMENTED] LAUNCH virtiofsd ON HOST INSTEAD OF CONTAINER
  #
  # Optionally, launch virtiofsd on host and bind-mount socket into container
  # HOST_SOCKET="/tmp/.virtiofs-$ID.sock"
  # touch $HOST_SOCKET
  # /usr/lib/qemu/virtiofsd --socket-path=$HOST_SOCKET -o cache=always -o source=$ROOT >/tmp/virtiofsd.log 2>&1 &  
  
  ARG0=$(jq_get "$CFG" '.process.args[0]')
  # Now look in mounts for destination == $ARG0 (this works for Docker and Podman)
  if [ "$ARG0" = "/sbin/docker-init" ] || [ "$ARG0" = "/dev/init" ]; then
  
    # User intended an init process to be run in the container,
    # so arrange to run our own instead, that will launch the original entrypoint
    
    # Look for and remove a mountpoint for this process.
    jq_set "$CFG" --arg init "$ARG0" '(.mounts[] | select(.destination == $init)) |= empty'
    
    # Replace the first argument with our own entrypoint; and remove the second, '--' (for now, #TODO)
    jq_set "$CFG" --arg entrypoint "$DKVM_ENTRYPOINT" '.process.args[0] = $entrypoint | del(.process.args[1])'
    
    # We know the user intended an init process to be run in the container.
    # TODO: We might want to indicate this, so that our entrypoint does not skip doing this
    # if the original entrypoint also looks like an init process.
    set_config_env "DKVM_INIT" "1"
  else
    # We don't know if the original entrypoint is an init process or not.
    # Run our entrypoint first to work this out and do the right thing.
    
    jq_set "$CFG" --arg entrypoint "$DKVM_ENTRYPOINT" '.process.args |= [$entrypoint] + .'
  fi

  # CONFIGURE USER
  # - Must be root to run container
  DKVM_UIDGID=$(jq_get_join "$CFG" '.process.user.uid, ":", .process.user.gid')
  set_config_env "DKVM_UIDGID" "$DKVM_UIDGID"
  jq_set "$CFG" '.process.user = {"uid":0, "gid":0}'

  # CONFIGURE MOUNTS
  set_config_env "DKVM_VM_MOUNTPOINT" "$DKVM_VM_MOUNTPOINT"

  # First extract list of tmpfs mounts in fstab form, then delete them from the config
  DKVM_TMPFS=$(jq_get "$CFG" '( .mounts[] | select(.type == "tmpfs" and (.destination | test("^/dev(/|$)") | not) ) ) | [.source + " " + .destination + " tmpfs " + (.options | map(select(. != "rprivate" and . != "private")) | join(",")) + " 0 0"] | .[0]')
  jq_set "$CFG" -r 'del( .mounts[] | select(.type == "tmpfs" and (.destination | test("^/dev(/|$)") | not) ) )'
  set_config_env "DKVM_TMPFS" "$DKVM_TMPFS"

  # Rewrite all pre-existing bind/volume mounts to mount to $DKVM_VM_MOUNTPOINT instead of /
  # If we excluded /etc/(resolv.conf,hosts,hostname), and moved these to top of the array
  # (by promoting them at the end of the below statements), they would be present in both
  # container and VM.
  #
  # N.B. A mount at /disks will not be mapped to /vm/disks - this path reserved for mounting disk files to the container
  jq_set "$CFG" --arg vm "$DKVM_VM_MOUNTPOINT" '( .mounts[] | select(.type == "bind" and .destination != "/disks") ).destination |= $vm + .'

  # Mount / from container to $DKVM_VM_MOUNTPOINT, recursively binding all pre-existing mount points
  # (these being only the ones defined ahead of this item in the mounts[] array - so order matters!)
  jq_set "$CFG" --arg root "$ROOT" --arg vm "$DKVM_VM_MOUNTPOINT" '.mounts |= [{"destination":$vm,"type":"bind","source":$root,"options":["rbind","private","rw"]}] + .'

  # Mount a tmpfs at /.dkvm in container
  # Define this at top of mounts[] so it is recursively mounted
  jq_set "$CFG" --arg dkvm "$DKVM" '.mounts |= [{"destination":"/.dkvm","type":"tmpfs","source":"dkvm","options":["nosuid","noexec","nodev","size=1M","mode=700"]}] + .'

  # Mount /opt/dkvm from host to container
  # Define this at top of mounts[] so it is recursively mounted
  jq_set "$CFG" --arg dkvm "$DKVM" '.mounts |= [{"destination":$dkvm,"type":"bind","source":$dkvm,"options":["bind","private","ro"]}] + .'

  # Mount a tmpfs at /run in container
  # Define this at bottom of mounts[] so it is not recursively mounted to /vm
  jq_set "$CFG" '.mounts += [{"destination":"/run","type":"tmpfs","source":"run","options":["nosuid","noexec","nodev","size=1M","mode=700"]}]'

  # DETERMINE LAUNCH KERNEL:
  #
  # 1. If DKVM_KERNEL specified:
  #    - <dist> or <dist>/latest - use latest DKVM kernel available for this dist
  #    - <dist>/<version> - use specific DKVM kernel version for this dist
  # 2. Else, check /etc/os-release and:
  #    a. Use builtin kernel for this dist (if present in the expected location)
  #    b. Use latest DKVM kernel available for the dist:
  #      - ID=alpine, VERSION_ID=3.16.0 => alpine/latest
  #      - ID=debian, VERSION_ID=11     => debian/latest
  #      - ID=ubuntu, VERSION_ID=22.04  => ubuntu/latest
  
  DKVM_KERNEL=$(get_config_env 'DKVM_KERNEL')
  log "DKVM_KERNEL #1=$DKVM_KERNEL"
  if [ -z "$DKVM_KERNEL" ]; then
    
    DKVM_KERNEL_OS_ID=$(load_env_from_file "$ROOT/etc/os-release" "ID")
    
    # Currently unused
    # DKVM_KERNEL_OS_VERSION_ID=$(load_var_from_env "$ROOT/etc/os-release" "VERSION_ID")
    
    if [ -n "$DKVM_KERNEL_OS_ID" ]; then
    
      case "$DKVM_KERNEL_OS_ID" in
          debian) DKVM_KERNEL_OS_KERNEL="/vmlinuz"
                  DKVM_KERNEL_OS_INITRAMFS="/initrd.img"
                  DKVM_KERNEL_ARGS="rootfstype=virtiofs root=myfs noresume nomodeset"
                  ;;
          ubuntu) DKVM_KERNEL_OS_KERNEL="/boot/vmlinuz"
                  DKVM_KERNEL_OS_INITRAMFS="/boot/initrd.img"
                  DKVM_KERNEL_ARGS="rootfstype=virtiofs root=myfs noresume nomodeset"
                  ;;
              ol) DKVM_KERNEL_OS_KERNEL="/boot/vmlinuz"
                  DKVM_KERNEL_OS_INITRAMFS="/boot/initramfs"
                  DKVM_KERNEL_ARGS="root=virtiofs:myfs noresume nomodeset"
                  ;;
          alpine) DKVM_KERNEL_OS_KERNEL="/boot/vmlinuz-virt"
                  DKVM_KERNEL_OS_INITRAMFS="/boot/initramfs-virt"
                  DKVM_KERNEL_ARGS="rootfstype=virtiofs root=myfs resume= nomodeset"
                  ;;

               *) error "Unrecognised image O/S '$DKVM_KERNEL_OS_ID'; specify --env=DKVM_KERNEL=<dist> or --env=DKVM_KERNEL=<dist>/<version>"; ;;
      esac
    
      if [[ -f "$ROOT/$DKVM_KERNEL_OS_KERNEL" && -f "$ROOT/$DKVM_KERNEL_OS_INITRAMFS" ]]; then
        DKVM_KERNEL_PATH="$DKVM_KERNEL_OS_KERNEL"
        DKVM_KERNEL_INITRAMFS_PATH="$DKVM_KERNEL_OS_INITRAMFS"
      else
        # If we can't find a kernel and initramfs at the expected paths, just select the latest DKVM kernel
        # for this distribution (assuming we have one).
        DKVM_KERNEL="$DKVM_KERNEL_OS_ID/latest"
        log "DKVM_KERNEL #2=$DKVM_KERNEL"
      fi
    fi
  fi  
 
  if [ -n "$DKVM_KERNEL" ]; then
  
    if [[ "$DKVM_KERNEL" =~ ^[a-z]+$ ]]; then
      DKVM_KERNEL+="/latest"
    fi
  
    if [[ "$DKVM_KERNEL" =~ \.\. ]]; then
      error "Kernel '$DKVM_KERNEL' invalid (contains '..')"
    fi
  
    if ! [[ "$DKVM_KERNEL" =~ ^[a-z]+/[^/]+$ ]]; then
      error "Kernel '$DKVM_KERNEL' invalid (should match ^[a-z]+/[^/]++$)"
    fi
  
    if ! [ -d "$DKVM_KERNELS/$DKVM_KERNEL" ]; then
      error "Kernel '$DKVM_KERNEL' not found (check $DKVM_KERNELS)"
    fi

    DKVM_KERNEL_ID=$(dirname "$DKVM_KERNEL") # Returns e.g. alpine, debian, ubuntu
    DKVM_KERNEL_VERSION=$(basename $(readlink -f "$DKVM_KERNELS/$DKVM_KERNEL")) # Returns e.g. 5.15.53-0-virt

    DKVM_KERNEL_MOUNT_LIB_MODULES=$(get_config_env 'DKVM_KERNEL_MOUNT_LIB_MODULES')
    if [ -n "$DKVM_KERNEL_MOUNT_LIB_MODULES" ]; then
      DKVM_KERNEL_MODULES_SRC="$DKVM_KERNELS/$DKVM_KERNEL_ID/$DKVM_KERNEL_VERSION/modules"
      DKVM_KERNEL_MODULES_DST="/lib/modules"
    else
      DKVM_KERNEL_MODULES_SRC="$DKVM_KERNELS/$DKVM_KERNEL_ID/$DKVM_KERNEL_VERSION/modules/$DKVM_KERNEL_VERSION"
      DKVM_KERNEL_MODULES_DST="/lib/modules/$DKVM_KERNEL_VERSION"
    fi
    
    DKVM_KERNEL_PATH="$DKVM_KERNELS/$DKVM_KERNEL_ID/$DKVM_KERNEL_VERSION/vmlinuz"
    DKVM_KERNEL_INITRAMFS_PATH="$DKVM_KERNELS/$DKVM_KERNEL_ID/$DKVM_KERNEL_VERSION/initrd"
  
    jq_set "$CFG" --arg modules_dst "$DKVM_VM_MOUNTPOINT$DKVM_KERNEL_MODULES_DST" --arg modules_src "$DKVM_KERNEL_MODULES_SRC" '.mounts += [{"destination":$modules_dst,"type":"bind","source":$modules_src,"options":["bind","private","ro"]}]'
  fi

  log "DKVM_KERNEL=$DKVM_KERNEL"
  log "DKVM_KERNEL_ID=$DKVM_KERNEL_ID"
  log "DKVM_KERNEL_VERSION=$DKVM_KERNEL_VERSION"
  log "DKVM_KERNEL_OS_ID=$DKVM_KERNEL_OS_ID"
  log "DKVM_KERNEL_OS_VERSION_ID=$DKVM_KERNEL_OS_VERSION_ID"
  log "DKVM_KERNEL_OS_KERNEL=$DKVM_KERNEL_OS_KERNEL"
  log "DKVM_KERNEL_OS_INITRAMFS=$DKVM_KERNEL_OS_INITRAMFS"
  log "DKVM_KERNEL_PATH=$DKVM_KERNEL_PATH"
  log "DKVM_KERNEL_INITRAMFS_PATH=$DKVM_KERNEL_INITRAMFS_PATH"
  log "DKVM_KERNEL_ARGS=$DKVM_KERNEL_ARGS"
  
  set_config_env "DKVM_KERNEL_PATH" "$DKVM_KERNEL_PATH"
  set_config_env "DKVM_KERNEL_INITRAMFS_PATH" "$DKVM_KERNEL_INITRAMFS_PATH"
  set_config_env "DKVM_KERNEL_ARGS" "$DKVM_KERNEL_ARGS"

  # Configure devices
  jq_set "$CFG" '.linux.resources.devices += [{"allow":true,"type":"c","major":10,"minor":232,"access":"rwm"},{"allow":true,"type":"c","major":10,"minor":200,"access":"rwm"}]'
  jq_set "$CFG" '.linux.devices+=[{"path":"/dev/net/tun","type":"c","major":10,"minor":200,"fileMode":8630,"uid":0,"gid":0},{"path":"/dev/kvm","type":"c","major":10,"minor":232,"fileMode":8630,"uid":0,"gid":0}]'
  
  # For now, hardcode --security-opt=seccomp=unconfined;
  # later, we can work out the minimal seccomp permissions required.
  jq_set "$CFG" '.linux.seccomp |= empty'
  
  # Set /dev/shm to DKVM_MEM_SIZE env var, or to default
  # - it should be large enough to support VM memory
  DKVM_MEM_SIZE=$(get_config_env "DKVM_MEM_SIZE")
  if [ -z "$DKVM_MEM_SIZE" ]; then
    DKVM_MEM_SIZE="$DKVM_MEM_SIZE_DEFAULT"
    set_config_env "DKVM_MEM_SIZE" "$DKVM_MEM_SIZE"
  fi
  
  log "DKVM_MEM_SIZE=$DKVM_MEM_SIZE"
  jq_set "$CFG" --arg size "$DKVM_MEM_SIZE" '( .mounts[] | select(.destination == "/dev/shm") ) = {"destination": "/dev/shm","type": "tmpfs","source": "shm","options": ["nosuid","noexec","nodev","mode=1777","size=" + $size]}'
  
  # Add non-default capabilities needed by:
  # - Docker: CAP_NET_ADMIN
  # - Podman: CAP_NET_ADMIN, CAP_NET_RAW, CAP_MKNOD, CAP_AUDIT_WRITE
  for field in bounding effective permitted
  do
    jq_set "$CFG" --arg field "bounding" '.process.capabilities[$field] |= (.+ ["CAP_NET_ADMIN","CAP_NET_RAW","CAP_MKNOD","CAP_AUDIT_WRITE"] | unique)'
  done
  
  debug && cp -a $CFG /tmp/config.json-$$-2
  
  # Filter for DKVM_SYS_ADMIN=1
  DKVM_SYS_ADMIN=$(get_config_env "DKVM_SYS_ADMIN")
  if [ "$DKVM_SYS_ADMIN" = "1" ]; then
    # TODO use 'unique'
    jq_set "$CFG" '.process.capabilities.bounding += ["CAP_SYS_ADMIN"] | .process.capabilities.effective += ["CAP_SYS_ADMIN"] | .process.capabilities.permitted += ["CAP_SYS_ADMIN"]'
  fi
  
elif [ "$COMMAND" = "exec" ]; then

  debug && log "Command: exec"

  # USAGE:
  #   runc exec [command options] <container-id> <command> [command options]  || -p process.json <container-id>
  #
  # PARSE 'exec' COMMAND OPTIONS
  # --console-socket value             path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal
  # --cwd value                        current working directory in the container
  # --env value, -e value              set environment variables
  # --tty, -t                          allocate a pseudo-TTY
  # --user value, -u value             UID (format: <uid>[:<gid>])
  # --additional-gids value, -g value  additional gids
  # --process value, -p value          path to the process.json
  # --detach, -d                       detach from the container's process
  # --pid-file value                   specify the file to write the process id to
  # --process-label value              set the asm process label for the process commonly used with selinux
  # --apparmor value                   set the apparmor profile for the process
  # --no-new-privs                     set the no new privileges value for the process
  # --cap value, -c value              add a capability to the bounding set for the process
  # --preserve-fds value               Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total) (default: 0)
  # --cgroup value                     run the process in an (existing) sub-cgroup(s). Format is [<controller>:]<cgroup>.
  # --ignore-paused                    allow exec in a paused container    
  while true
  do
    case "$1" in
      --console-socket|--cwd|--env|-e|--user|-u|--additional-gids|-g|--pid-file|--process-label|--apparmor|--cap|-c|--preserve-fds|--cgroup) shift; shift; continue; ;;
      --tty|-t|--detach|-d|--no-new-privs|--ignore-paused) shift; continue; ;;
      --process|-p) shift; PROCESS="$1"; continue; ;;
      *) break; ;;
    esac
  done

  if debug; then
    log "Command: exec process=$PROCESS"
    
    # Save formatted process.json
    jq -r . <$PROCESS >/tmp/process.json-$$-1
  fi

  ARG1=$(jq_get "$PROCESS" '.args[0]')
  if [ "$ARG1" = "---" ]; then
    jq_set "$PROCESS" 'del(.args[0])'
  else
    uidgid=$(jq_get_join "$PROCESS" '.user.uid, ":", .user.gid')
    cwd=$(jq_get "$PROCESS" '.cwd')

    jq_set "$PROCESS" --arg exec "$DKVM_EXEC" --arg uidgid "$uidgid" --arg cwd "$cwd" '.args |= [$exec, $uidgid, $cwd] + .'

    # Force root (or whatever user qemu runs as)
    # Force cwd in the container to / 
    jq_set "$PROCESS" '.user = {"uid":0, "gid":0} | .cwd="/"'
  fi
  
  debug && cp -a $PROCESS /tmp/process.json-$$-2
fi

debug && log "--- LOG ENDS ---"

exec /usr/bin/runc "${COMMAND_LINE[@]}"
