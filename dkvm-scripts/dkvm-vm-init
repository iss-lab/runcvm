#!/opt/dkvm/bin/bash

. /opt/dkvm/scripts/dkvm-ctr-defaults && PATH="$DKVM_PATH"

# Alpine initrd doesn't honour command-line rw flag
mount -o remount,rw /

# Unmount /run if it is a tmpfs (not a virtiofs) mounted by the initramfs
# /run may be populated in the underlying image, and may also be a volume or be bind-mounted,
# and its contents should be accessible in these cases.
if [ "$(findmnt -rnu -o FSTYPE /run)" = "tmpfs" ]; then
  busybox umount -fl /run
fi

# FIXME: virtiofs mounts aren't always made rw. Remount them all rw (if allowed)
# /opt/dkvm/bin/mount -t virtiofs | awk '{print $3}' | xargs -n 1 mount -o remount,rw

# Some systems do not set up /dev/fd. If needed, add it.
if ! [ -h /dev/fd ]; then
  ln -s /proc/self/fd /dev/fd
fi

# FIXME: This must be run early enough, otherwise other interfaces like docker0 might have started
IF=$(ls /sys/class/net/ | grep -vE '^(lo|docker)' | head -n 1)

IP=$(cat /.dkvm/net)
GW=$(cat /.dkvm/netgw)

# https://bugzilla.redhat.com/show_bug.cgi?id=501934
for i in all $IF
do
  # /sbin/sysctl -q -w -e net.ipv6.conf.$i.disable_ipv6=1 net.ipv6.conf.$i.autoconf=0 net.ipv6.conf.$i.accept_ra=0
  sysctl -q -w -e net.ipv6.conf.$i.disable_ipv6=1 net.ipv6.conf.$i.autoconf=0
done

# Bring up local interface
ip link set lo up

# Rename the first deterministically named interface to eth0
ip link set $IF name eth0 && IF=eth0
ip addr add $IP dev $IF
ip link set $IF up

# TODO
# - bind-mount or overwrite /etc/resolv.conf, /etc/hosts and /etc/hostname

route add default gw $GW

# Setup hostname
hostname -F /etc/hostname

# Mount filesystems defined in /etc/fstab OR as defined in DKVM_DISKS
if [ -f /.dkvm/fstab ]; then
  busybox modprobe ext4
  mount -av --fstab /.dkvm/fstab -o X-mount.mkdir
fi

# FIXME: THIS IS NOT RELIABLE!
# IT OVERRIDES PATH CAUSING cat and rm etc to break if not present in the image
# SAFER WOULD BE TO ADDRESS EVERY TOOL WITH AN ABSOLUTE PATH

# Load original environment
. /.dkvm/config

if [ "$DKVM_INIT" = "1" ]; then
  # If launched with '--init' (or --env=DKVM_INIT=1) then run our own init in place of Docker's/Podman's.

  $DKVM/bin/cat >/etc/inittab <<_EOE_
ttyS0::respawn:-/opt/dkvm/scripts/dkvm-vm-start
::respawn:/opt/dkvm/scripts/dkvm-vm-qemu-ga
::ctrlaltdel:/opt/dkvm/bin/poweroff
::restart:/opt/dkvm/bin/poweroff
_EOE_

  # Allow dkvm-vm-start to runs once (and only once)
  $DKVM/bin/rm -f /.dkvm/once

  # Clear the environment, and run our own init
  exec -c /opt/dkvm/bin/init
else
  # If not, assume the user knows what they're doing: launch qemu-ga and just run their entrypoint.

  # Clean DKVM env vars
  clean_env

  # Run the qemu guest agent, needed to support 'docker exec'
  $DKVM/scripts/dkvm-vm-qemu-ga &

  # Run init from the image
  # Pipe input/output from/to serial console
  exec </dev/ttyS0 &>/dev/ttyS0
  # Invoke dkvm-init with --no-fork purely to create controlling tty,
  # then exec dkvm-vm-start
  exec -c $DKVM/sbin/dkvm-init --no-fork $DKVM/scripts/dkvm-vm-start
fi
