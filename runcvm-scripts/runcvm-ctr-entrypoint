#!/opt/runcvm/bin/bash

# DEBUG
if [[ "$RUNCVM_BREAK" =~ (prenet|postnet) ]]; then set -x; fi

# SAVE ENTRYPOINT
args=("$@")
printf "%s\n" "${args[@]}" >/.runcvm/entrypoint

# SET HOME ENV VAR IF NEEDED

# - See https://github.com/moby/moby/issues/2968#issuecomment-35822318
#   for details of how Docker sets HOME.
#
# - What this means is that:
#   1. if HOME is defined in the image and
#      docker run:
#      a. does not define HOME
#         - config.json process.env[] will show the image-defined value and this value will be used
#         - docker exec
#           - does not define HOME, then process.json env[] will show the image-defined value and this value will be used
#           - does define HOME, then process.json env[] will show the exec-defined value and this value will be used
#      b. does define HOME, config.json process.env[] will show the docker run-defined value and this value will be used
#         - docker exec
#           - does not define HOME, then process.json env[] will show the docker run-defined value and this value will be used
#           - does define HOME, then process.json env[] will show the exec-defined value and this value will be used
#   (the above is irrespective of -u setting)
#
#   2. if HOME is not defined in the image and
#      docker run:
#      a. does not define HOME
#         - config.json process.env[] will show no HOME value and the user's default homedir will be used
#         - docker exec
#           - does not define HOME, then process.json env[] will show no HOME value and the user's default homedir will be used
#           - does define HOME, then process.json env[] will show the exec-defined value and this value will be used
#      b. does define HOME, config.json process.env[] will show the docker run-defined value and this value will be used
#         - docker exec
#           - does not define HOME, then process.json env[] will show the docker run-defined value and this value will be used
#           - does define HOME, then process.json env[] will show the exec-defined value and this value will be used

# Problem in 2a for us with docker run and docker exec is that while we save the requested uid:gid, we set the actual uid:gid to 0:0
# to allow us to run virtiofsd (and, today, qemu) (in the docker run case) and access the qemu guest agent socket (in the docker exec case).
#
# Where HOME is not explicitly defined, this leads to docker setting HOME to root's default homedir (typically /root),
# for the calls to runcvm-ctr-entrypoint and runcvm-ctr-exec (respectively).
#
# How then do we distinguish this case from the case where HOME is explicitly set to /root?
# The answer is that runcvm-runtime must check for HOME in env[] and indicate its presence in the calls to runcvm-ctr-entrypoint and runcvm-ctr-exec.
#
# runcvm-runtime does this:
# - in the docker run case, via the RUNCVM_HAS_HOME env var
# - in the docker exec case, via an argument to runcvm-ctr-exec

# Here we check RUNCVM_HAS_HOME to determine whether the HOME env var was set either in the image, or via docker run.
# If not, then we set HOME to the requested user's default homedir in accordance with https://github.com/moby/moby/issues/2968.

if [ "$RUNCVM_HAS_HOME" == "0" ]; then
  HOME=$(getent passwd "${RUNCVM_UIDGID%%:*}" | cut -d':' -f6)
fi

# SAVE ENVIRONMENT
export -n SHLVL OLDPWD

export >/.runcvm/config

# NOW LOAD DEFAULT ENV AND PATH
. /opt/runcvm/scripts/runcvm-ctr-defaults && PATH="$RUNCVM_PATH"

# SAVE PWD
busybox pwd >/.runcvm/pwd

# DEBUG
if [[ "$RUNCVM_BREAK" =~ prenet ]]; then bash; fi

# SAVE NETWORKING CONFIG
DOCKER_IF=$(ip -json route show | jq -r '.[] | select(.dst == "default") | .dev')
DOCKER_GW=$(ip -json route show | jq -r '.[] | select(.dst == "default") | .gateway')
DOCKER_NET=$(ip -json route show | jq -r '.[] | select(.dst != "default") | .dst')
DOCKER_IP_NET=$(ip addr show dev $DOCKER_IF | grep inet | head -n 1 | awk '{print $2}')
DOCKER_IP=$(echo $DOCKER_IP_NET | cut -d'/' -f1)

QEMU_BRIDGE_IP=169.254.1.1
RUNCVM_DNS_IP=169.254.169.254

echo $DOCKER_IP_NET >/.runcvm/net
echo $DOCKER_GW >/.runcvm/netgw

# RECONFIGURE CONTAINER NETWORK
ip addr flush dev $DOCKER_IF

# Create the container bridge
# See https://bugs.launchpad.net/neutron/+bug/1738659
ip link add $QEMU_BRIDGE type bridge forward_delay 0 ageing 0

# Add a private IP to the bridge.
# We need it so the bridge can receive traffic, but the IP won't ever see the light of day.
ip addr add $QEMU_BRIDGE_IP dev $QEMU_BRIDGE

# Add the original container interface to the bridge and bring it up.
ip link set dev $DOCKER_IF master $QEMU_BRIDGE
ip link set dev $DOCKER_IF up

# Bring the bridge up!
ip link set dev $QEMU_BRIDGE up

# Restore routes needed for the bridge
ip route add $DOCKER_NET dev $QEMU_BRIDGE
ip route add default via $DOCKER_GW dev $QEMU_BRIDGE

# Accept DNS requests for $RUNCVM_DNS_IP; these will be passed to dnsmasq
XTABLES_LIBDIR=/opt/runcvm/lib64/usr/lib/xtables/ /opt/runcvm/sbin/xtables-nft-multi iptables -t nat -A PREROUTING -d $RUNCVM_DNS_IP/32 -p udp -m udp --dport 53 -j REDIRECT

# Ensure all outgoing traffic via the QEMU bridge from the bridge's own IP is masqueraded as if from the VM
XTABLES_LIBDIR=/opt/runcvm/lib64/usr/lib/xtables/ /opt/runcvm/sbin/xtables-nft-multi iptables -t nat -A POSTROUTING -o $QEMU_BRIDGE -s $QEMU_BRIDGE_IP/32 -j SNAT --to-source $DOCKER_IP

# FIXME: Bind-mount /etc/resolv.conf as well as /vm/etc/resolv.conf to prevent them showing in 'docker diff'
cat /vm/etc/resolv.conf >/etc/resolv.conf
RESOLV_CONF_NEW=$(busybox sed -r 's/127.0.0.11/169.254.169.254/' /vm/etc/resolv.conf)
echo "$RESOLV_CONF_NEW" >/vm/etc/resolv.conf

# LAUNCH DNSMASQ
# It will receive local DNS requests (within the container, on 127.0.0.1)
# and requests redirected locally (via the iptables PREROUTING REDIRECT rule) for $RUNCVM_DNS_IP.
dnsmasq -u root --no-hosts

# LAUNCH VIRTIOFSD
/opt/runcvm/scripts/runcvm-ctr-virtiofsd &

# DEBUG
if [[ "$RUNCVM_BREAK" =~ postnet ]]; then bash; fi

# LAUNCH INIT SUPERVISING QEMU
# FIXME: Add -v to debug
exec /opt/runcvm/sbin/runcvm-init -c /opt/runcvm/scripts/runcvm-ctr-qemu